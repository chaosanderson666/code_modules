# useful-code-modules
The collection of useful code modules.

***
### 软件定时器：timer.c、timer.h
> **功能**：提供软件定时器功能，结构功能简单，适用于定时器需求数量较小的系统（几个以内），具体占用内存大小可根据定义的定时器结构体算出，可以更改结构体中的tick变量类型，从而获取更长的定时时间（也意味着占用更多的内存空间）。当增加定时器时，定时器负荷会线性增加，这是因为每一次tick到来都会查询所有定时器的tick数是否为0，如果为0，则调用他们的回调函数。定时器的回调函数应该尽可能的短，最好小于一个tick的时间，否则会丢失tick，造成定时不精确。如果要求定时器很精确，可以考虑在ISR中调用回调函数，这样相当于立即执行回调函数，但是此时回调函数的执行时间一定要短。

> **使用**：TMR_MAX_TMR_NUM（在timer.h文件中）定义了最大可以使用的定时器数量，最多256个（定时器ID编号为0~255）。调用函数timer_create()创建各定时器之前应先调用timer_init()函数初始化定时器列表。每发生一次tick时调用函数timer_tick()，它会通知timer_task()函数一个tick时间到。如果没有操作系统，timer_task()函数可在大循环中调用，它会不断地检查一个tick通知是否到来，如果有操作系统，timer_task()函数就在任务中调用，可用信号量等方式通知它一个tick到来。

> **改进（未实现）**：如果定时器的回调函数的执行时间超过了一个tick，那么这个tick将会丢失，这会造成定时不准确，为了克服这一点，可以考虑记录到来的tick数，而不是记录一个tick，这样每次timer_task()函数不是减去一个tick而是实际的tick数。从而提高定时精度，但是这种方法只适用于中断产生的tick，在大循环中产生的tick不会有任何改进。如果定时器的剩余定时tick数小于了到来的tick数，那么也会丢失相应的tick数，所以不能保证定时的绝对精确，但是这种方法还是有效的改进了定时精度。
***
### Delta软件定时器：timer_delta.c、timer_delta.h
> **功能**：和普通定时器模块不同，Delta定时器存储的不是实际的tick数，而是各个定时器tick数的差值，这样每个tick到来就只需检查第一个定时器的tick是否用完，不用每个tick都去把所有定时器的tick减一，当想要实现比较多的定时器时，用此方法效率高，一个小缺点是，由于使用了链表，所以占用的内存要比普通定时器多些。

> **使用**：可以使用静态数组或者动态内存分配为每个定时器创建存储空间，其他使用方式和上面的普通定时器一样。
定时器基本特点：不管是普通定时器还是delta定时器，当定时器数量变多时，定时精度都有可能下降，在这方面delta定时器的表现要好得多。定时器的回调函数不应该执行过长时间，如果回调函数的执行时间超过了一个tick，那么这个tick就会丢失，从而影响定时器精度，所以建议回调函数的执行时间不要超过一个tick的时间。当各个定时器的定时时间一样时，系统负荷最重，因为当定时时间到时，需要在同一时间执行完所有定时器的回调函数，所以应该尽量避免定时器的定时时间一样。
***
